<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Slope</title>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <style>
  /*gmaps*/
  html,
  body{
    font-family: 'Open Sans', sans-serif;
    height: 100%;
    margin: 0px;
    padding: 0px
  }
  #map-canvas {
    height: 100%;
    width: 60%;
    margin: 0px;
    padding: 0px
  }
  #wrapper {
    position: absolute;
    top: 80%;
    left: 5%;
    width: 50%;
    height:1.4em;
    /*margin-left: -180px;*/
    z-index: 5;
    background-color: #fff;
    padding: 0px;
    padding-bottom: 3px;
    border: 1px solid #999;
  }
  #input-panel {left: 50%;margin-left: 10px;width:100%;}
  .output-panel {margin-left: 5em;margin-top: 1em}
  .controls {
    width: 40%;
    height:100%;
  }
  /*.wrapper>.input-panel( #start.controls #end.controls #go._ )*/
  /*gmaps*/

  .buttonsCanvas{width:98%;margin-left: 20px;}
  button{width:10%;}
  #slopeMap button.buttonArrows{ font-size:1em; width: 15%}



  #go{width:14%;}


  canvas{
    /*  width:100%;
    height:80%;*/
    /*border: 2px inset brown;*/
    overflow:hidden;
  }
  /*.info, {
  padding:2em;
  border-radius: 5px;
  left:5%;
}*/

/*.dataTables_wrapper{
overflow:hidden;
}
button{
float:right;
}*/
.slider {
  overflow-y: hidden;
  max-height: 600px;

  transition-property: all;
  transition-duration: .5s;
  transition-timing-function: cubic-bezier(0, 1, 0.5, 1);

  background: pink;
  height: 600px;
  width: 600px;
}

.slider.closed {
  max-height: 0;
}
.upsideDown{transform: rotate(-180deg);  }
#slopeMap{
  position: absolute;
  top:0;
  right:0;
  /*width: 40%;*/
  height: 100%;

}
#menuButton{
  font-size:2em;
  height:3em;
  width:3em;
  /*float:right;*/
}
#menu{
  height:3em;width:3em;
  /*overflow:hidden;*/
}
.medium{height:60%; width:40%;   transition: all 900ms;}
.large{ height:100%;width:100%;  transition: all 900ms;}

#slopeMap button{width:16%;height:1.5em;}
</style>
<script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?libraries=places&sensor=false"></script>
</head>
<body>
  <div id="wrapper">
    <div id="input-panel">
      <input id="start" class="controls" type="text" placeholder="Start: ">
      <input id="end" class="controls" type="text" placeholder="End: ">
      <button id="go" onclick="calcRoute(latLongArray);">Directions</button>
    </div>

  </div>
  <div id="map-canvas"></div>













  <div id="slopeMap" class="medium">
    <canvas id="c" ></canvas>
    <!-- ➜ -->
    <div class="buttonsCanvas">
      <button class="buttonArrows" id="left">←</button>
      <button class="buttonArrows" id="right">→</button>

      <button class="buttonArrows"  id="up">↑</button>
      <button class="buttonArrows"  id="down">↓</button>

      <button class="buttonArrows upsideDown" id="zoomIN">+☌</button>
      <button class="buttonArrows upsideDown"  id="zoomOUT">-☌</button>
    </div>


    <div class="output-panel">
      <div id="travel-distance">
        Distance:
        <span id="distance"></span>
      </div>
      <div>
        Travel Time:
        <span id="travel-time"></span>
      </div>
      <div>
        Meters to Climb:
        <span id="climb"></span>
      </div>
      <div>
        Total meters of Descent:
        <span id="descent"></span>
      </div>
    </div>


  </div>
</div>



<script>








  // CANVAS------------------------------------------------------------
  function cc(a){console.log(a)}
  function $id(idTAG){return document.getElementById(idTAG)}
  // $id( "zoomIN").onclick=




  var X=0,Y=1,Z=2


  // data as [ [ x, x1, x2, ... ], [y, y1, y2, ... ], ... ]


  //SAMPLESIZE
  function gMaps3array(elevations,dx){ // [ [x,...], [y,..], ... ]
    var xx=[], yy=[], zz=[], el, X=0,Y=1,Z=2
    for (var i = 0, el; i < elevations.length; i++) {
      el=elevations[i]
      xx.push( el.location.lng() )
      yy.push( el.location.lat() )
      zz.push( el.elevation      )
    };

    // var routes = this.directions.routes;
    // distance = routes[0].legs[0].distance;
    // var SAMPLESIZE = 300
    // var dx = distance.value / SAMPLESIZE
    // var dx =  108.6 //for SAMPLESIZE = 10
    // var dx = 54.3  //for SAMPLESIZE = 20
    // var dx = 3.62 //for SAMPLESIZE = 300
    // var dx = 54.3
    cc("SAMPLESIZE:");cc(SAMPLESIZE)
    cc("dx:");cc(dx)

    var slopes=[0]
    for (var i = 1; i < elevations.length; i++) {
      var dy = zz[i] - zz[i-1]
      slopes.push(dy / dx * 100)
    };
    return [xx, yy, zz, slopes]
  };

  function toRange(min, max, min1, max1, x) {
    var range0 = max - min
    var range1 = max1 - min1
    return range1 / range0 * (x - min) + min1
  }

  function maxx(arr, ismax, col) {
    mx = Math[ismax].apply(Math, arr.map(function(v) {
      return v[col];
    }))
    return mx
  }
  function range(array) {
    return max(array) - min(array)
  }

  function min(array) {
    return Math.min.apply(Math, array)
  }

  function max(array) {
    return Math.max.apply(Math, array);
  }


  function normalize(data8) {

    var X2, Y2, Z2, X=0,Y=1,Z=2, COLORS, SLOPE=3
    var range0  = max([range(data8[X]), range(data8[Y])]);//keep aspect ratio
    var rangeEl = range(data8[Z])
    var rangeSl = range(data8[SLOPE])
    var min1    = -10// screen coordinates, will be multiplied by 10 to be in range -100,100px
    var minX    = min(data8[X])
    var minY    = min(data8[Y])
    var minZ    = min(data8[Z])
    var minEl   = min(data8[SLOPE])
    var r=100,g=100,b=100
    var dt = 0
    X2 = data8[X].map( function(x){ return 20/range0*(x-minX)+min1} )
    Y2 = data8[Y].map( function(x){ return 20/range0*(x-minY)+min1} )
    Z2 = data8[Z].map( function(x){ return 10/rangeEl*(x-minZ)+0} )
    COLORS = data8[SLOPE].map( function(x){
      r=rnd(255/rangeSl*(x-minEl)+0);
      g=(r>150)?0:50;
      b=(r>120)?50:100;
      return "rgb("+r+","+g+","+b+")"
    } )//rgb
    return [X2, Y2, Z2, COLORS]
  }

  // function data2range(array, range) {
  //   var min = Math.min.apply(Math, array);
  //   var max = Math.max.apply(Math, array);
  //   var min1 = range[0]
  //   var max1 = range[1]
  //   return array.map(function(x) {
  //     return toRange(min, max, min1, max1, x)
  //   })
  // }
  // d8 = data8.map( function(x){ return data2range(x, [-10,10]) })
  // data9.each( function(){ } )



  //-------------
  var b   = document.body,
  c   = document.getElementById("c");
  c.width = innerWidth*.4;
  c.height= innerHeight*0.7;
  var t   = c.getContext("2d"),

  f   = 200,
  mX  = 0,
  mY  = 0,
  π   = Math.PI,
  τ   = 2*π,
  sqrt= Math.sqrt,
  cos = Math.cos,
  sin = Math.sin,
  rnd = Math.round,
  centerX = c.width / 2,
  centerY = c.height / 2,
  totalθ=0,
  totalφ=0,
  targetAngleUP=π*7/6,
  targetAngle=0,
  zoom= 0.5,
  zoomTarget= 1.6,
  previous,
  timer=0;
  function toggleTimer(){if(timer===0){timer = setInterval(main,0)}}
  $id( "right") .onclick = function(){targetAngle += π/4;toggleTimer()}
  $id( "left")  .onclick = function(){targetAngle -= π/4;toggleTimer()}
  $id( "up")    .onclick = function(){targetAngleUP += π/6;toggleTimer()}
  $id( "down")  .onclick = function(){targetAngleUP -= π/6;toggleTimer()}
  $id( "zoomIN").onclick = function(){zoomTarget *= 1.3;toggleTimer()}
  $id( "zoomOUT").onclick = function(){zoomTarget /= 1.3;toggleTimer()}
  // $id( "menuButton").onclick = function(){
  //   //var butn=document.getElementById("slopeMap")
  // // butn.classList.toggle('large');// >IE9
  // // butn.classList.toggle('medium');// >IE9

  // document.getElementById("c").classList.toggle('large');// >IE9
  // document.getElementById("c").classList.toggle('medium');// >IE9

  // }

  c.onmousewheel =    function (e) {// chrome only
    // if(!loop)return null
    if        (e.wheelDelta > 0)  zoom *= 1.1
    else if   (e.wheelDelta < 0)  zoom /= 1.1
    if(zoom>maxzoom)zoom=maxzoom
    if(zoom<minzoom)zoom=minzoom}

    c.onmousemove = function(e){
      mX = e.clientX;
      mY = e.clientY;
    }
    c.addEventListener("click", function(event){
      cordinate_x = event.offsetX;
      cordinate_y = event.offsetY;
      console.log( "x,y: ( "+event.offsetX +", "+event.offsetY+" )" )
    });

    function fnPlane(x,y){
      return  0
    }

    function fn(x,y){
      var abs = sqrt( x*x + y*y )||1;
      return  π*sin(abs)/abs
    }

    function createGrid(fn){
      var p = [], rowlength=0, gridx=10, gridy=10, detail=1;
      for(var x = -gridx; x < gridx; x+=detail)
      for(var y = -gridy; y < gridy; y+=detail){
        if( x=== -gridx )rowlength++
        p.push({
          x: x*10,
          y: y*10,
          z: 20*fn(x,y)       })
        }
        p.rowlength=rowlength
        return p
      };

      function createSlope(arr){
        var p = [], rowlength=arr[0].length;
        for(var i = 0; i < rowlength; i++ ){
          p.push({ x: arr[X][i]*10, y: arr[Y][i]*10, z: arr[Z][i]*10, color:arr[3][i]})
        }

        for(var i = 0; i < rowlength; i++ ){
          p.push({ x: arr[X][i]*10, y: arr[Y][i]*10, z: 0})
        }
        p.rowlength=rowlength
        return p
      };

      function rotate(plane) {
        var
        θ = π / 4 / 270, //0.002;
        φ = π / 6 / 70,
        zoomINCR = 0.004,
        err = 0.0001
        if ((totalθ < (targetAngle + err)) &&
        (totalθ > (targetAngle - err)) &&
        (totalφ < (targetAngleUP + err)) &&
        (totalφ > (targetAngleUP - err)) &&
        (zoom < (zoomTarget + 0.1)) &&
        (zoom > (zoomTarget - 0.1))
        ) {
          cc("-===")
          // cc("totalφ")
          // cc("totalφ")
          if (timer) {
            clearInterval(timer);
            timer = 0
          }
        }
        if (zoom < zoomTarget) zoom += zoomINCR
        if (zoom > zoomTarget) zoom -= zoomINCR

        if (totalθ < targetAngle) totalθ += θ
        if (totalθ > targetAngle) totalθ -= θ

        if (totalφ < targetAngleUP) totalφ += φ
        if (totalφ > targetAngleUP) totalφ -= φ
        // totalφ+=φ
        θ = totalθ
        φ = totalφ //=π/4
        var
        cosθ = cos(θ),
        sinθ = sin(θ),
        cosφ = cos(φ),
        sinφ = sin(φ),
        pnt, Scale, x1, y1, z1, x, y, z;
        for (var i = plane.length; i--;) {
          pnt = plane[i];
          x = pnt.x;
          y = pnt.y;
          z = pnt.z;

          // x1     = x  * cosθ -  z * sinθ;//rotate XZ, about Y
          // z1     = x  * sinθ +  z * cosθ;
          x1 = x * cosθ - y * sinθ; //rotate XY, about Z
          y1 = x * sinθ + y * cosθ;
          x = x1
          y = y1
          y = y1
          z1 = z * cosφ - y * sinφ; //rotate YZ, about X
          y1 = z * sinφ + y * cosφ;

          Scale = f / (f + z1) * zoom;

          pnt._x = centerX + x1 * Scale;
          pnt._y = centerY + y1 * Scale;
        }

      }

      function draw(p) {
        t.strokeStyle = "rgb(20,50,20)";
        t.beginPath();
        var rowlength=p.rowlength
        t.moveTo(p[0]._x, p[0]._y);
        var l = rowlength;
        for (var i = 1; i < p.length-rowlength; i++)
        if (i % rowlength) {
          var beneath = i+rowlength;
          if(p[i].color){
            t.beginPath();
            t.moveTo(p[i]._x, p[i]._y);
          }
          t.lineTo(p[i]._x,         p[i]._y);
          t.lineTo(p[beneath]._x,   p[beneath]._y);
          t.lineTo(p[beneath-1]._x, p[beneath-1]._y);
          t.lineTo(p[i-1]._x,       p[i-1]._y);
          t.moveTo(p[i]._x,         p[i]._y);
          if(p[i].color){
            t.fillStyle = p[i].color;
            t.fill();
          }
          // t.fillText(i, p[i]._x, p[i]._y)

        }
        else t.moveTo(p[i]._x, p[i]._y);


        t.stroke()
        var now = Date.now();
        dt = now - (previous||0)

        //t.fillText("draw time: "+dt, 100, 100)
        //t.fillText("angle θ: "+(totalθ/π), 100, 120)
        //t.fillText(targetAngle, 100, 140)
        previous = now
      }

      function drawCircle(x,y,color,radius,txt){
        var oldColor=t.fillStyle
        t.beginPath();
        t.arc(x, y, radius, 0, 2 * Math.PI, false);
        t.fillStyle = color;
        t.fill();
        t.fillStyle = "white";
        t.fillText(txt, x-radius/3, y+radius/3)
        t.fillStyle = oldColor;

      }

      function drawLine(x1,y1,x2,y2,color){
        var oldColor=t.strokeStyle
        t.beginPath();
        t.moveTo(x1,y1);
        t.lineTo(x2,y2);
        t.strokeStyle = color;
        t.stroke();
        t.strokeStyle = oldColor;
      }

      function main(){
        t.clearRect(0, 0, c.width, c.height);
        planes.forEach( rotate )
        planes.forEach( draw )
        var p = planes[1]
        drawCircle(p[0]._x,p[0]._y,"green",10,"A")
        drawCircle(p[p.rowlength-1]._x,p[p.rowlength-1]._y,"red",10,"B")
      }










    </script>
    <script>
      // GOOGLE MAPS------------------------------------------------------------


      function cc(a) {console.log(a)} //debug

      var directionsDisplay;
      var directionsService = new google.maps.DirectionsService();
      var autocomplete;
      var elevation_data = null;
      var elevations = [];
      var distance = null;
      var duration = null;
      var markersArray = [];
      var mapPaths = [];
      var polyline;
      var routes = null;
      var slopes = null;
      var SAMPLESIZE = 500;

      function initialize() {
        var renderOptions = {
          draggable: true, //routes draggable
          hideRouteList: true,
          polylineOptions: {
            strokeOpacity: 0
          }
        };
        var melbourne = new google.maps.LatLng(-37.813776, 144.963397);
        directionsDisplay = new google.maps.DirectionsRenderer(renderOptions);
        var mapCanvas = document.getElementById('map-canvas');

        var mapOptions = {
          center: melbourne,
          zoom: 14,
          // change map type to ROADMAP for faster loading
          mapTypeId: google.maps.MapTypeId.ROADMAP
        };

        // provides the user with autocomplete functionality
        autocomplete = new google.maps.places.Autocomplete(
        (document.getElementById('start')), {
          types: ['geocode']
        });
        autocomplete = new google.maps.places.Autocomplete(
        (document.getElementById('end')), {
          types: ['geocode']
        });

        map = new google.maps.Map(mapCanvas, mapOptions);
        directionsDisplay.setMap(map);
        elevation_data = new google.maps.ElevationService();

        // update paths onClick.
        google.maps.event.addListener(directionsDisplay, 'routeindex_changed', updateRoutes);

        autocomplete.bindTo('bounds', map);
        directionsDisplay.setMap(map);
      }

      latLongArray = [
      [-0.00000000, 0.000000000],
      // [-37.8173561, 144.9674856],
      [-1.1111111111, 1.1111111111]
      ]

      function calcRoute(latLongArray) {

        wayPointsArray = [];
        if (latLongArray.length === 2) {
          // return wayPointsArray = []; as previously defined
        } else if (latLongArray.length > 2) {

          for (i = 1; i < latLongArray.length - 1; i++) {
            // cc(latLongArray[i]);
            wayPointsArray.push({
              location: new google.maps.LatLng(latLongArray[i][0], latLongArray[i][1]),
              stopover: false
            })
          }
          console.log(wayPointsArray);
        }

        var start = document.getElementById('start').value + ", Victoria, Australia";
        var end   = document.getElementById('end').value + ", Victoria, Australia";
        // cc('end value: ' + end)
        var request = {
          origin: start,
          destination: end,
          travelMode: google.maps.TravelMode.BICYCLING,
          waypoints: wayPointsArray,
          optimizeWaypoints: true
        };

        directionsService.route(request, function(response, status) {
          if (status == google.maps.DirectionsStatus.OK) {
            cc("response"+response)
            directionsDisplay.setDirections(response);
          }
        });
      }

      google.maps.event.addDomListener(window, 'load', initialize);

      var updating = false;

      function updateRoutes() {
        if (updating) return;
        updating = true;
        setTimeout(function() {
          updating = false;
        }, 100);
        console.log("Updating routes");
        cc('this: '+this)
        var routes = this.directions.routes;
        var path = routes[0].overview_path;
        distance = routes[0].legs[0].distance;
        duration = routes[0].legs[0].duration;

        document.getElementById('distance').innerHTML = (distance.value / 1000) + "Km";
        document.getElementById('travel-time').innerHTML = duration.text;

        var pathRequest = {
          'path': path,
          'samples': SAMPLESIZE
        };
        // Send an elevation request to google
        elevation_data.getElevationAlongPath(pathRequest, plotElevation);
      }

      // Google returns elevation data to the plotElevation
      function plotElevation(elevations, status) {
        plotSlope(elevations, SAMPLESIZE);

      }

      function plotSlope(elevations, SAMPLESIZE) {

        slopes = [];
        for (i = 0; i < elevations.length - 1; i++) {
          slope = (calcSlope(elevations[i + 1].elevation, elevations[i].elevation, distance.value / SAMPLESIZE)) * 100;
          slopes.push({
            slope: slope,
            location: midpoint(elevations[i], elevations[i + 1])
          });
        }
        drawPolyline(elevations, slopes);

        var data8 = gMaps3array(elevations, distance.value / SAMPLESIZE )
        planes=[  createGrid(fnPlane),  createSlope( normalize(data8) ) ]

        totalθ=0,
        totalφ=0,
        targetAngleUP=π*7/6,

        targetAngle=0,
        zoom= 0.5,
        zoomTarget= 1.6,

        timer = setInterval(main,0);
        cc(elevations, SAMPLESIZE);
      }

      function removePolylines() {
        for (var i = 0; i < mapPaths.length; i++) {
          mapPaths[i].setMap(null);
        }
        mapPaths = [];
      }

      function drawPolyline(elevations, slopes) {
        // Create a polyline between each elevation, color code by slope.
        // Remove any existing polylines before drawing a new polyline.
        removePolylines();
        // Define /reset distanceClimbed, distanceDescended
        var upHill = 0;
        var downHill = 0;


        for (var i = 0; i < slopes.length; i++) {
          var routePath = [
          elevations[i].location,
          elevations[i + 1].location
          ];
          var slope   = slopes[i].slope;
          var current = elevations[i].elevation
          var next    = elevations[i + 1].elevation;
          switch (true){ //currentSlope
            case(slope>12):
            pathColor = "red";
            upHill += next - current;
            break;
            case(slope>8):
            pathColor = "orange";
            upHill += next - current;
            break;
            case(slope>4):
            pathColor = "yellow";
            upHill += next - current;
            break;
            case(slope>0):
            pathColor = "blue";
            upHill += next - current;
            break;
            default:
            pathColor = "black";
            downHill += current - next;
          }
          mapPath = new google.maps.Polyline({
            path: routePath,
            strokeColor: pathColor,
            strokeOpacity: 0.5,
            strokeWeight: 8,
            draggable: true
          });
          mapPath.setMap(map);
          mapPaths.push(mapPath);
        }//for
        document.getElementById('climb').innerHTML = parseFloat(upHill).toFixed(2)+"m";
        document.getElementById('descent').innerHTML =  parseFloat(downHill).toFixed(2)+"m";
      }

      function elevationClear(x) {
        map.locationMarker.setMap(null);
      }

      function midpoint(point1, point2) {
        // To get the midpoint, find the average between each respective point
        var lat = (point1.location.lat() + point2.location.lat()) / 2;
        var lng = (point1.location.lng() + point2.location.lng()) / 2;
        return new google.maps.LatLng(lat, lng);
      }

      function calcSlope(y1, y2, dx) {
        return (y1 - y2) / dx;
      }

      function getURLParameter(name) {
        return decodeURIComponent((RegExp(name + '=' + '(.+?)(&|$)')
        .exec(location.search) || [, null])[1]);
      }




    </script>

  </body>
  </html>
  
