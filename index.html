<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Slope</title>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <style>
  /*gmaps*/
  html,
  body{
    font-family: 'Open Sans', sans-serif;
    height: 100%;
    margin: 0px;
    padding: 0px
  }
  #map-canvas {
    height: 100%;
    width: 60%;
    margin: 0px;
    padding: 0px
  }
  #wrapper {
    top: 80%;
    left: 5%;
    width: 50%;
    height:1.4em;
    /*margin-left: -180px;*/
    z-index: 5;
    background-color: #fff;
    padding: 0px;
    padding-bottom: 3px;
    border: 1px solid #999;
  }
  #input-panel {left: 50%;margin-left: 10px;width:100%;}
  .output-panel {margin-left: 5em;margin-top: 1em}
  .controls {
    width: 40%;
    height:100%;
  }
  /*.wrapper>.input-panel( #start.controls #end.controls #go._ )*/
  /*gmaps*/

  .buttonsCanvas{width:98%;margin-left: 20px;}
  button{width:10%;}
  #slopeMap button.buttonArrows{ font-size:1em; width: 15%}



  #go{width:14%;}


  canvas{
    /*  width:100%;
    height:80%;*/
    /*border: 2px inset brown;*/
    overflow:hidden;
  }
  /*.info, {
  padding:2em;
  border-radius: 5px;
  left:5%;
}*/

/*.dataTables_wrapper{
overflow:hidden;
}
button{
float:right;
}*/
.slider {
  overflow-y: hidden;
  max-height: 600px;

  transition-property: all;
  transition-duration: .5s;
  transition-timing-function: cubic-bezier(0, 1, 0.5, 1);

  background: pink;
  height: 600px;
  width: 600px;
}

.slider.closed {
  max-height: 0;
}
.upsideDown{transform: rotate(-180deg);  }
#slopeMap{
  position: absolute;
  top:0;
  right:0;
  /*width: 40%;*/
  height: 100%;

}
#menuButton{
  font-size:2em;
  height:3em;
  width:3em;
  /*float:right;*/
}
#menu{
  height:3em;width:3em;
  /*overflow:hidden;*/
}
.medium{height:60%; width:40%;   transition: all 900ms;}
.large{ height:100%;width:100%;  transition: all 900ms;}

#slopeMap button{width:16%;height:1.5em;}
/* from map escape*/
html, body, div, span, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
abbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,
small, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, figcaption, figure,
footer, header, hgroup, menu, nav, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}

article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}

blockquote, q { quotes: none; }
blockquote:before, blockquote:after,
q:before, q:after { content: ''; content: none; }
ins { background-color: #ff9; color: #000; text-decoration: none; }
mark { background-color: #ff9; color: #000; font-style: italic; font-weight: bold; }
del { text-decoration: line-through; }
abbr[title], dfn[title] { border-bottom: 1px dotted; cursor: help; }
table { border-collapse: collapse; border-spacing: 0; }
hr { display: block; height: 1px; border: 0; border-top: 1px solid #ccc; margin: 1em 0; padding: 0; }
input, select { vertical-align: middle; }

body { font:13px/1.231 sans-serif; *font-size:small; }
select, input, textarea, button { font:99% sans-serif; }
pre, code, kbd, samp { font-family: monospace, sans-serif; }

html { overflow-y: scroll; }
a:hover, a:active { outline: none; }
ul, ol { margin-left: 2em; }
ol { list-style-type: decimal; }
nav ul, nav li { margin: 0; list-style:none; list-style-image: none; }
small { font-size: 85%; }
strong, th { font-weight: bold; }
td { vertical-align: top; }
p { margin: 10px 0; }

sub, sup { font-size: 75%; line-height: 0; position: relative; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 15px; }
textarea { overflow: auto; }
.ie6 legend, .ie7 legend { margin-left: -7px; }
input[type="radio"] { vertical-align: text-bottom; }
input[type="checkbox"] { vertical-align: bottom; }
.ie7 input[type="checkbox"] { vertical-align: baseline; }
.ie6 input { vertical-align: text-bottom; }
label, input[type="button"], input[type="submit"], input[type="image"], button { cursor: pointer; }
button, input, select, textarea { margin: 0; }
input:invalid, textarea:invalid { border-radius: 1px; -moz-box-shadow: 0px 0px 5px red; -webkit-box-shadow: 0px 0px 5px red; box-shadow: 0px 0px 5px red; }
.no-boxshadow input:invalid, .no-boxshadow textarea:invalid { background-color: #f0dddd; }

button {  width: auto; overflow: visible; }
.ie7 img { -ms-interpolation-mode: bicubic; }

body, select, input, textarea { color: #757575; }
h1, h2, h3, h4, h5, h6 { font-weight: bold; }
a { color: #ae2642; text-decoration: none; }
a:hover { text-decoration: none; }


/* fonts */
body { width: 100%; background: #f4f4f4; font-size: 16px; color: #686868; }
header h1 { text-align: center; font-size: 24px; color: #ae2642; margin: 10px 0; }
h2 { color: #ae2642; font-size: 22px; text-transform: uppercase; margin: 40px 0 10px; }
footer { background: #fff; margin: 40px 0 0 ; padding: 40px 0 40px; }
footer .downloads { display: none; }

.top-bar { color: #fff; padding: 5px 2%; background: #000; }
.top-bar a { color: #fff; }
.top-bar .follow { float: right; width: 45%; text-align: right; }
.top-bar .follow a { display: inline-block; padding: 10px; }
.top-bar .code { width: 150px; height: 14px; float: left; margin-top: 10px; }
.top-bar .code img { width: 100%; }
.top-bar .t:hover { color: #00aced; }
.top-bar .f:hover { color: #3b5998; }
.top-bar .g:hover { color: #da573b; }

.header, .main, .footer-container, .map-demo p { width: 90%; margin: 0 5%; }
.header { text-align: center; padding: 40px 0 0; }
.header p { font-size: 14px; }

.intro { margin-bottom: 20px; }
.main p { line-height: 2; margin: 10px 0; }
.main img { width: 100%; }
.map-demo p { text-align: center;}
.btn { width: 100%; padding: 20px 30px 20px 70px; margin: 10px 0 0; text-align: left; position: relative; background: #ae2642; color: #fff; font-size: 16px; display: inline-block; box-sizing: border-box; border-radius: 2px; border: 2px solid rgba(255,255,255,.3); text-transform: uppercase; }
.btn .ss-icon { font-size: 20px; text-align: center; position: absolute; left: 20px; top: 10px; display: inline-block; width: 40px; height: 30px; padding: 10px 0 0; border-radius: 50px; background: rgba(0,0,0,.2); box-shadow: inset -1px 1px rgba(0,0,0,.2); }
.logo { width: 210px; height: 40px; display: inline-block; }
.logo img { width: 100%; }
.downloads { display: block; text-align: center; }
.downloads .btn { border: 0; background: transparent; color: #686868; width: auto; }
.downloads .btn:hover { color: #ae2642;}
.downloads .btn span { background: transparent; box-shadow: none; }
.dload { display: none; }


.demo-buttons { margin-bottom: 20px; }

.social-share { letter-spacing: -4px; position: relative; height: 40px; }
.social-share .sb { display: inline-block; letter-spacing: normal; width: 33%; height: 64px; position: relative; overflow: hidden; }
.social-share .atb { position: absolute; left: 10px; top: 10px; z-index: 1; }
.social-share .btn { display: none;}

.social-share.no-box { display: none; }

table td,
table th { width: 10%; text-align: left; padding: 5px 0; font-size: 12px; }
table td:nth-child(3),
table th:nth-child(3) { width: 13%; }
table td:last-child,
table th:last-child { width: 43%; }

table {  margin: 40px auto; }
table > thead:first-child > tr:first-child > th,
table > thead:first-child > tr:first-child > td { border-top: 0; }
table > thead:first-child > tr:first-child > th:first-child,
table > thead:first-child > tr:first-child > td:first-child { border-left: 0; }
table > thead:first-child > tr:first-child > th:last-child,
table > thead:first-child > tr:first-child > td:last-child { border-right: 0; }
table th { color: #313131; }
table th,
table td { border: 1px solid #e0e0e0; padding: 12px 2%; vertical-align: middle; }
table > thead th,
table > thead > td { background: #dfdfdf; border-color: #e9e9e9; padding-top: 20px; padding-bottom: 20px; }
table > tbody tr:nth-child(even) td,
table > tbody tr:nth-child(even) th { background-color: #fff; }

.code-snippet { background: #fff; border: 1px solid #e0e0e0; margin-bottom: 20px; }
.code-snippet h3 { display: block; margin: 1px 1px 15px; background: #f3f3f3;  padding: 10px 12px;}
.code-snippet pre.prettyprint { border: none; padding: 0 12px 20px 12px; }
.code-snippet pre.prettyprint .str { color: #ae2642 }  /* string content */
.code-snippet pre.prettyprint .com { color: #999 }  /* a comment */
/* punctuation, lisp open bracket, lisp close bracket */
.code-snippet pre.prettyprint .tag { color: #434343 }  /* a markup tag name */
.code-snippet pre.prettyprint .atn { color: #540e1d }  /* a markup attribute name */
.code-snippet pre.prettyprint .atv { color: #ae2642 }  /* a markup attribute value */


.ir { display: block; text-indent: -999em; overflow: hidden; background-repeat: no-repeat; text-align: left; direction: ltr; }
.hidden { display: none; visibility: hidden; }
.visuallyhidden { border: 0; clip: rect(0 0 0 0); height: 1px; margin: -1px; overflow: hidden; padding: 0; position: absolute; width: 1px; }
.visuallyhidden.focusable:active,
.visuallyhidden.focusable:focus { clip: auto; height: auto; margin: 0; overflow: visible; position: static; width: auto; }
.invisible { visibility: hidden; }
.clearfix:before, .clearfix:after { content: "\0020"; display: block; height: 0; overflow: hidden; }
.clearfix:after { clear: both; }
.clearfix { zoom: 1; }



@media print {
  * { background: transparent !important; color: black !important; text-shadow: none !important; filter:none !important;
    -ms-filter: none !important; }
    a, a:visited { color: #444 !important; text-decoration: underline; }
    a[href]:after { content: " (" attr(href) ")"; }
    abbr[title]:after { content: " (" attr(title) ")"; }
    .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
    pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
    thead { display: table-header-group; }
    tr, img { page-break-inside: avoid; }
    @page { margin: 0.5cm; }
    p, h2, h3 { orphans: 3; widows: 3; }
    h2, h3{ page-break-after: avoid; }
  }
</style>










<script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?libraries=places&sensor=false"></script>
</head>
<body>
  <div id="wrapper">
    <div id="input-panel">
      <input id="start" class="controls" type="text" placeholder="Start: ">
      <input id="end" class="controls" type="text" placeholder="End: ">
      <button id="go" onclick="calcRoute(latLongArray);">Directions</button>
    </div>

  </div>
  <div id="map-canvas"></div>













  <div id="slopeMap" class="medium">
    <canvas id="c" ></canvas>
    <!-- ➜ -->
    <div class="buttonsCanvas">
      <button class="buttonArrows" id="left">←</button>
      <button class="buttonArrows" id="right">→</button>

      <button class="buttonArrows"  id="up">↑</button>
      <button class="buttonArrows"  id="down">↓</button>

      <button class="buttonArrows upsideDown" id="zoomIN">+☌</button>
      <button class="buttonArrows upsideDown"  id="zoomOUT">-☌</button>
    </div>


    <div class="output-panel">
      <div id="travel-distance">
        Distance:
        <span id="distance"></span>
      </div>
      <div>
        Travel Time:
        <span id="travel-time"></span>
      </div>
      <div>
        Meters to Climb:
        <span id="climb"></span>
      </div>
      <div>
        Total meters of Descent:
        <span id="descent"></span>
      </div>
    </div>


  </div>
</div>



<script>








  // CANVAS------------------------------------------------------------
  function cc(a){console.log(a)}
  function $id(idTAG){return document.getElementById(idTAG)}
  // $id( "zoomIN").onclick=




  var X=0,Y=1,Z=2


  // data as [ [ x, x1, x2, ... ], [y, y1, y2, ... ], ... ]


  //SAMPLESIZE
  function gMaps3array(elevations,dx){ // [ [x,...], [y,..], ... ]
    var xx=[], yy=[], zz=[], el, X=0,Y=1,Z=2
    for (var i = 0, el; i < elevations.length; i++) {
      el=elevations[i]
      xx.push( el.location.lng() )
      yy.push( el.location.lat() )
      zz.push( el.elevation      )
    };

    // var routes = this.directions.routes;
    // distance = routes[0].legs[0].distance;
    // var SAMPLESIZE = 300
    // var dx = distance.value / SAMPLESIZE
    // var dx =  108.6 //for SAMPLESIZE = 10
    // var dx = 54.3  //for SAMPLESIZE = 20
    // var dx = 3.62 //for SAMPLESIZE = 300
    // var dx = 54.3
    cc("SAMPLESIZE:");cc(SAMPLESIZE)
    cc("dx:");cc(dx)

    var slopes=[0]
    for (var i = 1; i < elevations.length; i++) {
      var dy = zz[i] - zz[i-1]
      slopes.push(dy / dx * 100)
    };
    return [xx, yy, zz, slopes]
  };

  function toRange(min, max, min1, max1, x) {
    var range0 = max - min
    var range1 = max1 - min1
    return range1 / range0 * (x - min) + min1
  }

  function maxx(arr, ismax, col) {
    mx = Math[ismax].apply(Math, arr.map(function(v) {
      return v[col];
    }))
    return mx
  }
  function range(array) {
    return max(array) - min(array)
  }

  function min(array) {
    return Math.min.apply(Math, array)
  }

  function max(array) {
    return Math.max.apply(Math, array);
  }


  function normalize(data8) {

    var X2, Y2, Z2, X=0,Y=1,Z=2, COLORS, SLOPE=3
    var range0  = max([range(data8[X]), range(data8[Y])]);//keep aspect ratio
    var rangeEl = range(data8[Z])
    var rangeSl = range(data8[SLOPE])
    var min1    = -10// screen coordinates, will be multiplied by 10 to be in range -100,100px
    var minX    = min(data8[X])
    var minY    = min(data8[Y])
    var minZ    = min(data8[Z])
    var minEl   = min(data8[SLOPE])
    var r=100,g=100,b=100
    var dt = 0
    X2 = data8[X].map( function(x){ return 20/range0*(x-minX)+min1} )
    Y2 = data8[Y].map( function(x){ return 20/range0*(x-minY)+min1} )
    Z2 = data8[Z].map( function(x){ return 10/rangeEl*(x-minZ)+0} )
    COLORS = data8[SLOPE].map( function(x){
      r=rnd(255/rangeSl*(x-minEl)+0);
      g=(r>150)?0:50;
      b=(r>120)?50:100;
      return "rgb("+r+","+g+","+b+")"
    } )//rgb
    return [X2, Y2, Z2, COLORS]
  }

  // function data2range(array, range) {
  //   var min = Math.min.apply(Math, array);
  //   var max = Math.max.apply(Math, array);
  //   var min1 = range[0]
  //   var max1 = range[1]
  //   return array.map(function(x) {
  //     return toRange(min, max, min1, max1, x)
  //   })
  // }
  // d8 = data8.map( function(x){ return data2range(x, [-10,10]) })
  // data9.each( function(){ } )



  //-------------
  var b   = document.body,
  c   = document.getElementById("c");
  c.width = innerWidth*.4;
  c.height= innerHeight*0.7;
  var t   = c.getContext("2d"),

  f   = 200,
  mX  = 0,
  mY  = 0,
  π   = Math.PI,
  τ   = 2*π,
  sqrt= Math.sqrt,
  cos = Math.cos,
  sin = Math.sin,
  rnd = Math.round,
  centerX = c.width / 2,
  centerY = c.height / 2,
  totalθ=0,
  totalφ=0,
  targetAngleUP=π*7/6,
  targetAngle=0,
  zoom= 0.5,
  zoomTarget= 1.6,
  previous,
  timer=0;
  function toggleTimer(){if(timer===0){timer = setInterval(main,0)}}
  $id( "right") .onclick = function(){targetAngle += π/4;toggleTimer()}
  $id( "left")  .onclick = function(){targetAngle -= π/4;toggleTimer()}
  $id( "up")    .onclick = function(){targetAngleUP += π/6;toggleTimer()}
  $id( "down")  .onclick = function(){targetAngleUP -= π/6;toggleTimer()}
  $id( "zoomIN").onclick = function(){zoomTarget *= 1.3;toggleTimer()}
  $id( "zoomOUT").onclick = function(){zoomTarget /= 1.3;toggleTimer()}
  // $id( "menuButton").onclick = function(){
  //   //var butn=document.getElementById("slopeMap")
  // // butn.classList.toggle('large');// >IE9
  // // butn.classList.toggle('medium');// >IE9

  // document.getElementById("c").classList.toggle('large');// >IE9
  // document.getElementById("c").classList.toggle('medium');// >IE9

  // }

  c.onmousewheel =    function (e) {// chrome only
    // if(!loop)return null
    if        (e.wheelDelta > 0)  zoom *= 1.1
    else if   (e.wheelDelta < 0)  zoom /= 1.1
    if(zoom>maxzoom)zoom=maxzoom
    if(zoom<minzoom)zoom=minzoom}

    c.onmousemove = function(e){
      mX = e.clientX;
      mY = e.clientY;
    }
    c.addEventListener("click", function(event){
      cordinate_x = event.offsetX;
      cordinate_y = event.offsetY;
      console.log( "x,y: ( "+event.offsetX +", "+event.offsetY+" )" )
    });

    function fnPlane(x,y){
      return  0
    }

    function fn(x,y){
      var abs = sqrt( x*x + y*y )||1;
      return  π*sin(abs)/abs
    }

    function createGrid(fn){
      var p = [], rowlength=0, gridx=10, gridy=10, detail=1;
      for(var x = -gridx; x < gridx; x+=detail)
      for(var y = -gridy; y < gridy; y+=detail){
        if( x=== -gridx )rowlength++
        p.push({
          x: x*10,
          y: y*10,
          z: 20*fn(x,y)       })
        }
        p.rowlength=rowlength
        return p
      };

      function createSlope(arr){
        var p = [], rowlength=arr[0].length;
        for(var i = 0; i < rowlength; i++ ){
          p.push({ x: arr[X][i]*10, y: arr[Y][i]*10, z: arr[Z][i]*10, color:arr[3][i]})
        }

        for(var i = 0; i < rowlength; i++ ){
          p.push({ x: arr[X][i]*10, y: arr[Y][i]*10, z: 0})
        }
        p.rowlength=rowlength
        return p
      };

      function rotate(plane) {
        var
        θ = π / 4 / 270, //0.002;
        φ = π / 6 / 70,
        zoomINCR = 0.004,
        err = 0.0001
        if ((totalθ < (targetAngle + err)) &&
        (totalθ > (targetAngle - err)) &&
        (totalφ < (targetAngleUP + err)) &&
        (totalφ > (targetAngleUP - err)) &&
        (zoom < (zoomTarget + 0.1)) &&
        (zoom > (zoomTarget - 0.1))
        ) {
          cc("-===")
          // cc("totalφ")
          // cc("totalφ")
          if (timer) {
            clearInterval(timer);
            timer = 0
          }
        }
        if (zoom < zoomTarget) zoom += zoomINCR
        if (zoom > zoomTarget) zoom -= zoomINCR

        if (totalθ < targetAngle) totalθ += θ
        if (totalθ > targetAngle) totalθ -= θ

        if (totalφ < targetAngleUP) totalφ += φ
        if (totalφ > targetAngleUP) totalφ -= φ
        // totalφ+=φ
        θ = totalθ
        φ = totalφ //=π/4
        var
        cosθ = cos(θ),
        sinθ = sin(θ),
        cosφ = cos(φ),
        sinφ = sin(φ),
        pnt, Scale, x1, y1, z1, x, y, z;
        for (var i = plane.length; i--;) {
          pnt = plane[i];
          x = pnt.x;
          y = pnt.y;
          z = pnt.z;

          // x1     = x  * cosθ -  z * sinθ;//rotate XZ, about Y
          // z1     = x  * sinθ +  z * cosθ;
          x1 = x * cosθ - y * sinθ; //rotate XY, about Z
          y1 = x * sinθ + y * cosθ;
          x = x1
          y = y1
          y = y1
          z1 = z * cosφ - y * sinφ; //rotate YZ, about X
          y1 = z * sinφ + y * cosφ;

          Scale = f / (f + z1) * zoom;

          pnt._x = centerX + x1 * Scale;
          pnt._y = centerY + y1 * Scale;
        }

      }

      function draw(p) {
        t.strokeStyle = "rgb(20,50,20)";
        t.beginPath();
        var rowlength=p.rowlength
        t.moveTo(p[0]._x, p[0]._y);
        var l = rowlength;
        for (var i = 1; i < p.length-rowlength; i++)
        if (i % rowlength) {
          var beneath = i+rowlength;
          if(p[i].color){
            t.beginPath();
            t.moveTo(p[i]._x, p[i]._y);
          }
          t.lineTo(p[i]._x,         p[i]._y);
          t.lineTo(p[beneath]._x,   p[beneath]._y);
          t.lineTo(p[beneath-1]._x, p[beneath-1]._y);
          t.lineTo(p[i-1]._x,       p[i-1]._y);
          t.moveTo(p[i]._x,         p[i]._y);
          if(p[i].color){
            t.fillStyle = p[i].color;
            t.fill();
          }
          // t.fillText(i, p[i]._x, p[i]._y)

        }
        else t.moveTo(p[i]._x, p[i]._y);


        t.stroke()
        var now = Date.now();
        dt = now - (previous||0)

        //t.fillText("draw time: "+dt, 100, 100)
        //t.fillText("angle θ: "+(totalθ/π), 100, 120)
        //t.fillText(targetAngle, 100, 140)
        previous = now
      }

      function drawCircle(x,y,color,radius,txt){
        var oldColor=t.fillStyle
        t.beginPath();
        t.arc(x, y, radius, 0, 2 * Math.PI, false);
        t.fillStyle = color;
        t.fill();
        t.fillStyle = "white";
        t.fillText(txt, x-radius/3, y+radius/3)
        t.fillStyle = oldColor;

      }

      function drawLine(x1,y1,x2,y2,color){
        var oldColor=t.strokeStyle
        t.beginPath();
        t.moveTo(x1,y1);
        t.lineTo(x2,y2);
        t.strokeStyle = color;
        t.stroke();
        t.strokeStyle = oldColor;
      }

      function main(){
        t.clearRect(0, 0, c.width, c.height);
        planes.forEach( rotate )
        planes.forEach( draw )
        var p = planes[1]
        drawCircle(p[0]._x,p[0]._y,"green",10,"A")
        drawCircle(p[p.rowlength-1]._x,p[p.rowlength-1]._y,"red",10,"B")
      }










    </script>
    <script>
      // GOOGLE MAPS------------------------------------------------------------


      function cc(a) {console.log(a)} //debug

      var directionsDisplay;
      var directionsService = new google.maps.DirectionsService();
      var autocomplete;
      var elevation_data = null;
      var elevations = [];
      var distance = null;
      var duration = null;
      var markersArray = [];
      var mapPaths = [];
      var polyline;
      var routes = null;
      var slopes = null;
      var SAMPLESIZE = 500;

      function initialize() {
        var renderOptions = {
          draggable: true, //routes draggable
          hideRouteList: true,
          polylineOptions: {
            strokeOpacity: 0
          }
        };
        var melbourne = new google.maps.LatLng(-37.813776, 144.963397);
        directionsDisplay = new google.maps.DirectionsRenderer(renderOptions);
        var mapCanvas = document.getElementById('map-canvas');

        var mapOptions = {
          center: melbourne,
          zoom: 14,
          // change map type to ROADMAP for faster loading
          mapTypeId: google.maps.MapTypeId.ROADMAP
        };

        // provides the user with autocomplete functionality
        autocomplete = new google.maps.places.Autocomplete(
        (document.getElementById('start')), {
          types: ['geocode']
        });
        autocomplete = new google.maps.places.Autocomplete(
        (document.getElementById('end')), {
          types: ['geocode']
        });

        map = new google.maps.Map(mapCanvas, mapOptions);
        directionsDisplay.setMap(map);
        elevation_data = new google.maps.ElevationService();

        // update paths onClick.
        google.maps.event.addListener(directionsDisplay, 'routeindex_changed', updateRoutes);

        autocomplete.bindTo('bounds', map);
        directionsDisplay.setMap(map);
      }

      latLongArray = [
      [-0.00000000, 0.000000000],
      // [-37.8173561, 144.9674856],
      [-1.1111111111, 1.1111111111]
      ]

      function calcRoute(latLongArray) {

        wayPointsArray = [];
        if (latLongArray.length === 2) {
          // return wayPointsArray = []; as previously defined
        } else if (latLongArray.length > 2) {

          for (i = 1; i < latLongArray.length - 1; i++) {
            // cc(latLongArray[i]);
            wayPointsArray.push({
              location: new google.maps.LatLng(latLongArray[i][0], latLongArray[i][1]),
              stopover: false
            })
          }
          console.log(wayPointsArray);
        }

        var start = document.getElementById('start').value + ", Victoria, Australia";
        var end   = document.getElementById('end').value + ", Victoria, Australia";
        // cc('end value: ' + end)
        var request = {
          origin: start,
          destination: end,
          travelMode: google.maps.TravelMode.BICYCLING,
          waypoints: wayPointsArray,
          optimizeWaypoints: true
        };

        directionsService.route(request, function(response, status) {
          if (status == google.maps.DirectionsStatus.OK) {
            cc("response"+response)
            directionsDisplay.setDirections(response);
          }
        });
      }

      google.maps.event.addDomListener(window, 'load', initialize);

      var updating = false;

      function updateRoutes() {
        if (updating) return;
        updating = true;
        setTimeout(function() {
          updating = false;
        }, 100);
        console.log("Updating routes");
        cc('this: '+this)
        var routes = this.directions.routes;
        var path = routes[0].overview_path;
        distance = routes[0].legs[0].distance;
        duration = routes[0].legs[0].duration;

        document.getElementById('distance').innerHTML = (distance.value / 1000) + "Km";
        document.getElementById('travel-time').innerHTML = duration.text;

        var pathRequest = {
          'path': path,
          'samples': SAMPLESIZE
        };
        // Send an elevation request to google
        elevation_data.getElevationAlongPath(pathRequest, plotElevation);
      }

      // Google returns elevation data to the plotElevation
      function plotElevation(elevations, status) {
        plotSlope(elevations, SAMPLESIZE);

      }

      function plotSlope(elevations, SAMPLESIZE) {

        slopes = [];
        for (i = 0; i < elevations.length - 1; i++) {
          slope = (calcSlope(elevations[i + 1].elevation, elevations[i].elevation, distance.value / SAMPLESIZE)) * 100;
          slopes.push({
            slope: slope,
            location: midpoint(elevations[i], elevations[i + 1])
          });
        }
        drawPolyline(elevations, slopes);

        var data8 = gMaps3array(elevations, distance.value / SAMPLESIZE )
        planes=[  createGrid(fnPlane),  createSlope( normalize(data8) ) ]

        totalθ=0,
        totalφ=0,
        targetAngleUP=π*7/6,

        targetAngle=0,
        zoom= 0.5,
        zoomTarget= 1.6,

        timer = setInterval(main,0);
        cc(elevations, SAMPLESIZE);
      }

      function removePolylines() {
        for (var i = 0; i < mapPaths.length; i++) {
          mapPaths[i].setMap(null);
        }
        mapPaths = [];
      }

      function drawPolyline(elevations, slopes) {
        // Create a polyline between each elevation, color code by slope.
        // Remove any existing polylines before drawing a new polyline.
        removePolylines();
        // Define /reset distanceClimbed, distanceDescended
        var upHill = 0;
        var downHill = 0;


        for (var i = 0; i < slopes.length; i++) {
          var routePath = [
          elevations[i].location,
          elevations[i + 1].location
          ];
          var slope   = slopes[i].slope;
          var current = elevations[i].elevation
          var next    = elevations[i + 1].elevation;
          switch (true){ //currentSlope
            case(slope>12):
            pathColor = "red";
            upHill += next - current;
            break;
            case(slope>8):
            pathColor = "orange";
            upHill += next - current;
            break;
            case(slope>4):
            pathColor = "yellow";
            upHill += next - current;
            break;
            case(slope>0):
            pathColor = "blue";
            upHill += next - current;
            break;
            default:
            pathColor = "black";
            downHill += current - next;
          }
          mapPath = new google.maps.Polyline({
            path: routePath,
            strokeColor: pathColor,
            strokeOpacity: 0.5,
            strokeWeight: 8,
            draggable: true
          });
          mapPath.setMap(map);
          mapPaths.push(mapPath);
        }//for
        document.getElementById('climb').innerHTML = parseFloat(upHill).toFixed(2)+"m";
        document.getElementById('descent').innerHTML =  parseFloat(downHill).toFixed(2)+"m";
      }

      function elevationClear(x) {
        map.locationMarker.setMap(null);
      }

      function midpoint(point1, point2) {
        // To get the midpoint, find the average between each respective point
        var lat = (point1.location.lat() + point2.location.lat()) / 2;
        var lng = (point1.location.lng() + point2.location.lng()) / 2;
        return new google.maps.LatLng(lat, lng);
      }

      function calcSlope(y1, y2, dx) {
        return (y1 - y2) / dx;
      }

      function getURLParameter(name) {
        return decodeURIComponent((RegExp(name + '=' + '(.+?)(&|$)')
        .exec(location.search) || [, null])[1]);
      }




    </script>

  </body>
  </html>
